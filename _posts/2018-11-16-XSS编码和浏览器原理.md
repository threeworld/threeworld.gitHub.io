---
layout: default
category: Web安全
tags: [xss,Web安全]
---

> 一想起XSS，有的人不懂浏览器的解析原理就是一顿各种编码，然后一顿各种解析，结果浏览器还原不了原来的编码，然后与XSS漏洞擦肩而过，say byebye...，下面会介绍XSS常用的编码绕过和浏览器解析原理。

## 一、常见的XSS绕过编码

常见的XSS编码绕过有JS编码、HTML实体编码和URL编码，为什么这三种编码会如此常用呢（还有`base64编码`），因为浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析。所以会产生三种编码方式，下面将会详细说明。

### 1. JS编码

JS提供了四种字符编码的策略，如下：

1. JavaScript的八进制

```js
//三个八进制数字，如果个数不够，在前面补‘0’， 'e' => '\145'
```

1. JavaScript的十六进制

```js
//两个十六进制数字，如果个数不够，在前面补‘0’， 'e' => '\x65'
```

1. Jsunicode编码

```js
//四个十六进制数字，如果个数不够，在前面补'0', 'e' => '\u0065'
```

1. 对于一些控制字符，使用特殊的C类型的转义风格（例如 \n 和 \r）

### 2. HTML实体编码

1. 命名实体：以 `&` 开头，分号结尾，例如 `<` 的编码是 `&lt;`
2. 字符编码：`&#数值;`
   1. html 10进制，例如 `<` 的编码 `&#60;`
   2. html 16进制，例如 `<` 的编码 `&#x3c;`

### 3. URL编码

```jss
'<' => '%3C'
```

### 4. base64编码

```
'<' => 'PA=='
```

使用XSS编码测试时，需要考虑HTML渲染的顺序，组合多种方式，并且保证能还原会原来的内容。

## 二、浏览器的解析原理

在此之前，我们先来了解一下浏览器的构成：

1. 用户界面，也就是现在看到的地址栏等
2. 渲染引擎，包括HTML解析器，CSS解析器等，将页面显示出来
3. JS引擎，当然是负责解析JS代码的
4. UI后端，用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口
5. 数据存储，浏览器需要在硬盘中存取cookie等各种数据
6. 网络：负责网络请求

其中渲染引擎和JS引擎是要重点关注的， 下面是浏览器的解析过程：

![img](http://7s1s1q.com1.z0.glb.clouddn.com/2016-05-18-14635418258357.jpg)

可以看出有三个部分：

- HTML/SVG/XHTML解析
- CSS解析
- JS解析

浏览器先解析HTML，并将其标签转化为DOM节点，在此过程中，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。在此基础上，JavaScript DOM API 参与进来，可以对DOM 树进行修改，改变DOM树的结构和内容。而此时，CSS解析器则解析外部CSS 文件以及Style 标签中的样式内容，这些信息将搭配HTML 中的可见指令构建起一个渲染Tree。

### 深入理解编码和解码的顺序

在了解到浏览器的解析原理后，我们来看一下编码和解码的顺序。

我们来看个例子：

```html
<a href="javascript:alert('xss')" ></a>
```

对于以上的情况，我们来分析浏览器的解析顺序，首先，HTML解析器会对HTML中的标签转化为DOM节点，并生成DOM tree，建立起DOM tree树后，HTML会对实体编码进行解码，就是对`href`中字符进行HTML解码，因为`href` 对应着`url`，所以会触发`url`解析器对其进行解码，即`url`解码；如果`href `中`url`是`https://www.baidu.com`，`url`解析完就不会进行`js`解析了，但是该`url`资源类型为`javascript`，`javascript:`是伪协议，会触发`js`引擎来解析，即`js`解码；现在来整理一下解码的过程：

- HTML解码 --> URL解码 --> JS解码

现在做个测试一下:

1. 将`javascript:alert('xss')`进行HTML编码

```html
<a href='&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x27;&#x78;&#x73;&#x73;&#x27;&#x29;' >onclick</a>
```

当点击`onclik`时，网页弹出`XSS`

![1542169596420]({{site.url}}/images/1542169596420.png)

这说明了浏览器的HTML解析器会将其解码为`javascript:alert('xss')`。然后JS引擎将其解析。

1. 将`javascript:alert('xss')`进行URL编码

```html
<a href='%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29' >onclick</a>
```

会发现弹不了框，URL解码之后Javascript解析器完成解码操作，脚本应该会正常执行的，**原因**是什么呢？URL解析过程中**不能对协议类型进行任何的编码操作**，否则URL解析器会认为它无类型，也就是转化为字符文本。

1. 组合编码

   HTML字符实体编码 `javascript` 、URL 编码 `alert(2)`

   HTML编码`javascript`=`&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;`

   URL编码`alert(2)`=` %61%6C%65%72%74%28%32%29`

```html
<a href='&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;:%61%6C%65%72%74%28%32%29' >onclick</a>
```

![1542171070427]({{site.url}}/images/1542171070427.png)

"javascript"是做的HTML实体编码，HTML解析器工作时，href里的HTML实体会被解码，接下来URL解析器工作解析href属性里的链接时，"javascript"协议在第一步被HTML解码了，这样URL解析器是可以识别的，然后继续解析后面的”%61%6C%65%72%74%28%32%29”，最后JavaScript解析器完成解析操作，脚本执行。

1. 对`<a href="javascript:alert(3)">test3</a>`做JS编码->URL编码->HTML编码共3层。

实现了3层复合编码，每一层编码都能正常执行

**注意一点**：

像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，例如：`<script>alert('xss\u0027)</script>`对控制字符单引号进行js编码，解析时\u0027被解码成文本单引号，无法闭合因此不能成功执行。

**JavaScript解析时只有标识符名称不会被当做字符串，控制字符仅会被解析为标示符名称或者字符串**