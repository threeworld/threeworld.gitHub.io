---
layout: post
title:  "Apache Commons collections Java deserialization vulnerability revealed"
date:   2019-01-10 20:15:33 +0700
categories: [Web安全]
---

在上一篇文章中，已经介绍过Java序列化与反序列化有关的内容，[The Java serialization algorithm revealed](https://twoday.cc/web%E5%AE%89%E5%85%A8/2019/01/06/The-Java-serialization-algorithm-revealed.html)

在这篇文章中将会介绍2015年火热的Apache Commons Collections反序列化漏洞，影响范围广泛，包括 WebLogic, WebSphere, JBoss, Jenkins, OpenNMS 等等

FoxGlove Security安全团队的@breenmachinef发布了一篇[博客](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)，简述了借用Java反序列化和Apache Commons Collections这一基础类库实现远程命令执行的真实案例。

## 0x00 什么是Apache Commons collections?

看一下官方的解析：

![Snipaste_2019-01-09_11-08-46]({{site.url}}/images/Snipaste_2019-01-09_11-08-46.png)

Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。

## 0x01 关键方法分析

### **TransformedMap类**

commons collections 实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。

![Snipaste_2019-01-09_13-34-37]({{site.url}}/images/Snipaste_2019-01-09_13-34-37.png)

`TransformedMap`类

![Snipaste_2019-01-09_14-32-07]({{site.url}}/images/Snipaste_2019-01-09_14-32-07.png)

该类可以在一个元素被加入到map中自动对该元素进行修饰变换，也就是调用`keyTransformer/valueTransformer` 进行变换，**具体的逻辑可以自定义**，这是关键点。大概就是如下：

* 一个元素被加入到`map`中，`transformedMap` 函数对其`key/values` 进行修饰变换
* 因此`keyTransformer/valueTransformer` 方法被调用
* `map`里的元素都会被存储在`Map.Entry`的集合对象中

![Snipaste_2019-01-09_14-20-19]({{site.url}}/images/Snipaste_2019-01-09_14-20-19.png)

`checkValue()调用valueTransformer`

![Snipaste_2019-01-09_14-29-55]({{site.url}}/images/Snipaste_2019-01-09_14-29-55.png)

大致的流程图如下：

![Snipaste_2019-01-09_15-55-42]({{site.url}}/images/Snipaste_2019-01-09_15-55-42.png)

### **chainedTransformer类**

![Snipaste_2019-01-09_16-05-26]({{site.url}}/images/Snipaste_2019-01-09_16-05-26.png)

使用Transformer数组构造成ChainedTransformer。当触发时，ChainedTransformer可以按顺序调用一系列的变换。

### **InvokerTransformer 类**

首先看` InvokerTransformer` 类中的` transform()` 方法：

![Snipaste_2019-01-09_21-27-33]({{site.url}}/images/Snipaste_2019-01-09_21-27-33.png)

此类需要三个参数：

* `methodName`：方法的名称
* `paramType`：参数的类型
* `args`：参数

这个`transform(Object input)` 中使用Java反射机制调用了input对象的一个方法，而该方法名是实例化`InvokerTransformer`类时传入的`iMethodName`成员变量：

![Snipaste_2019-01-09_21-37-22]({{site.url}}/images/Snipaste_2019-01-09_21-37-22.png)

这个类十分重要，因为这个反射代码中调用的方法名和class对象都是可控的。所以我们可以构造一个`Transformer`链，通过调用`InvokerTransformer.transform`来运行恶意代码。

### **ConstantTransformer类**

可以将待变换的对象，变为一个常量，返回 iConstant 属性，该属性也为可控参数

### 测试代码

![Snipaste_2019-01-09_22-15-07]({{site.url}}/images/Snipaste_2019-01-09_22-15-07.png)

在上述代码中，我们构造了一个 `Transformer ` 数组` transformers` ，第一个参数是 `new ConstantTransformer(Runtime.class)` ，后续均为` InvokerTransformer `对象，最后用该 `Transformer `数组实例化了 `transformerChain `对象，然后使用`transformerChain` 修饰了`innerMap`，返回`outMap`，如果该`Map`的值发生改变时，那么`transformerChain`将会触发各自的`transform`方法，最终达到运行恶意代码。

构造`Transformer ` 数组` transformers` 运行的流程：

![Snipaste_2019-01-09_22-24-53]({{site.url}}/images/Snipaste_2019-01-09_22-24-53.png)

总的来说就是相当于运行了如下代码：

![Snipaste_2019-01-09_22-31-27]({{site.url}}/images/Snipaste_2019-01-09_22-31-27.png)

在上面我们知道，通过精心构造的`transformMap`类，在其任意值改变的时候，通过触发修饰变换，可以执行任意代码。

那么我们如何通过反序列化执行远程命令呢？

## 0x03 使用反序列化实现RCE

通过以上的分析，如果Java应用没有对传入的序列化数据进行安全性检查，我们可以将恶意的TransformedMap序列化后，远程提交给Java应用，如果Java应用可以触发变换，即可成功远程命令执行。

我们知道反序列化时会执行`readObject()`或者`readResolve()` 方法，所以我们现在需要找到一个反序列化类重写了`readObject()`方法，并且在此方法中会调用`Map.Entry.setValue()`方法。

于是我们找到了` AnnotationInvocationHandler` 类

![Snipaste_2019-01-09_23-10-50]({{site.url}}/images/Snipaste_2019-01-09_23-10-50.png)

这个类有一个成员变量 memberValues 是 Map 类型，它的`readObject`方法如下

```java
private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
    var1.defaultReadObject();
    AnnotationType var2 = null;

    try {
        var2 = AnnotationType.getInstance(this.type);
    } catch (IllegalArgumentException var9) {
        throw new InvalidObjectException("Non-annotation type in annotation serial stream");
    }

    Map var3 = var2.memberTypes();
    Iterator var4 = this.memberValues.entrySet().iterator();

    while(var4.hasNext()) {
        Entry var5 = (Entry)var4.next();
        String var6 = (String)var5.getKey();
        Class var7 = (Class)var3.get(var6);
        if(var7 != null) {
            Object var8 = var5.getValue();
            if(!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) {
                var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6)));
            }
        }
    }
}
```

AnnotationInvocationHandler的readObject()函数中对memberValues的每一项调用了setValue()函数，由上面可知，`setValue()`函数最终会触发`checkValue()`方法

那么server端的处理流程如下图：

![Snipaste_2019-01-10_10-35-50]({{site.url}}/images/Snipaste_2019-01-10_10-35-50.png)

那么最后的payload：

![Snipaste_2019-01-10_10-56-30]({{site.url}}/images/Snipaste_2019-01-10_10-56-30.png)

因为AnnotationInvocationHandler是私有的包，我们使用反射时需要`setAccessible(true)`。

## 0x04 总结

在上面的内容中我们知道了该漏洞的原理，由于对反序列化对象没有检查，导致了任意代码的执行。在下一篇文章中我会介绍如何利用该漏洞。