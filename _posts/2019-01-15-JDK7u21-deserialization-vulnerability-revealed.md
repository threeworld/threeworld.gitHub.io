---
layout: post
title:  "JDK7u21-deserialization-vulnerability-revealed"
date:   2019-01-15 20:15:33 +0700
categories: [Web安全]
---

## 0x00 介绍

- Affected Product(s): Java SE 6, Java SE 7
- Fixed in: Java SE 7u25 (2013-06-18), Java SE 8 (2014-03-18)
- Vendor Contact: [secalert_us@oracle.com](mailto:secalert_us@oracle.com)
- Vulnerability Type: Unsafe Object Deserialization
- Remote Exploitable: Yes
- Reported to vendor: 2015-12-18
- Disclosed to public: 2016-01-26
- Release mode: Coordinated release
- CVE: N/A, Mitigated in June 2013 Critical Patch Update (see [ysoserial#6](https://github.com/frohoff/ysoserial/issues/6))

## 0x01 描述

利用JDK本身的漏洞，但影响范围在`jdk<7u21`，漏洞作者也在GitHub上给出了一些分析https://gist.github.com/frohoff/24af7913611f8406eaf3，在查阅很多资料难以理解，一方面缺少Java的相关知识，另一方面缺少实践，所以尝试debug，并且对相关知识进行分析。

## 0x02 相关知识

### "f5a5a608".hashcode==0

Java Object 中定义了 `hashCode()` 方法，返回一个 hash 值，当两个对象 equals 时，hashCode 需要相同。String类重写了该方法。

![Snipaste_2019-01-15_11-04-36]({{site.url}/images/Snipaste_2019-01-15_11-04-36.png)

`f5a5a608`字符串很特殊，它的hashcode为0。

### 动态代理

Java的动态代理十分灵活，只需要为一组接口指定好`InvocationHandler`对象，`InvocationHandler`是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，在这个方法中可以通过反射执行原方法，也可以做一些其他操作。参考 https://juejin.im/post/5a99048a6fb9a028d5668e62

所有的`Handler`类都需要实现`InvocationHandler`这个接口，当我们通过代理对象调用某个方法的时候，这次调用就会被转派到Handler的invoke方法:

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

该方法有三个参数：

* `proxy` ：被代理的对象
* `method`：这个参数表示传入接口中的所有Method对象
* `args`：这个参数对应当前method方法中的参数

当创建好`InvocationHandler`对象后，就可以通过`Proxy.newProxyInstance`方法来创建动态代理，该方法的声明如下：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException
```

* `loader`： 定义由那个`ClassLoader`对象来对生成的代理对象进行加载
* `interfaces`：interface对象的数组，表示将要给需要代理的对象提供的一组什么接口
* `h`：`InvocationHandler`对象，表示当目前这个动态代理对象在调用方法的时候应当关联到哪一个`InvocationHandler`对象上

例子：

```java
public class InvocationHandlerTests {

    //@Test
    public static void testInvocationHandler() throws Exception {
        // 被代理的对象
        Map map = new HashMap();
        // JDK 本身只支持动态代理接口
        // 创建 proxy object，参数为 ClassLoader、要代理的接口Class array、实际处理方法调用的 InvocationHandler
        Map proxy = (Map) Proxy.newProxyInstance(InvocationHandlerTests.class.getClassLoader(), new Class[]{Map.class}, new MyInvocationHandler(map));
        proxy.put("key", "value");
        proxy.get("key");
    }

    public static class MyInvocationHandler implements InvocationHandler {
        private Map map;

        public MyInvocationHandler(Map map) {
            this.map = map;
        }

        // 实际的方法调用都会变成调用 invoke 方法
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("method: " + method.getName() + " start");
            Object result = method.invoke(map, args);
            System.out.println("method: " + method.getName() + " finish");
            return result;
        }
    }
    public static void main(String[] args){
        try {
            testInvocationHandler();
        }catch (Exception e){
            e.printStackTrace();
        }

    }
}
//运行后输出
/*print:
    method: put start
    method: put finish
    method: get start
    method: get finish
*/
```

### javassist 字节码操作库

项目地址：https://github.com/jboss-javassist/javassist

该库提供了在运行时操作Java字节码的方法，如在已有 Class 中动态修改和插入 Java 代码

在[payload](https://gist.github.com/frohoff/24af7913611f8406eaf3)中，作者使用javassist 来构造包含恶意代码的class

```java
public static TemplatesImpl createTemplatesImpl(final String command) throws Exception {
    // 利用TemplatesImpl类来触发恶意的bytescode
    final TemplatesImpl templates = new TemplatesImpl();

    // 获取容器ClassPool，注入classpath
    ClassPool pool = ClassPool.getDefault();
    System.out.println("insertClassPath: " + new ClassClassPath(StubTransletPayload.class));
    pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));

    // 获取已经编译好的类
    System.out.println("ClassName: " + StubTransletPayload.class.getName());
    final CtClass clazz = pool.get(StubTransletPayload.class.getName());

    // 在静态的的构造方法中插入payload
    clazz.makeClassInitializer()
            .insertAfter("java.lang.Runtime.getRuntime().exec(\""
                    + command.replaceAll("\"", "\\\"")
                    + "\");");

    // 给payload类设置一个名称
    // unique name to allow repeated execution (watch out for PermGen exhaustion)
    clazz.setName("ysoserial.Pwner" + System.nanoTime());

    // 获取该类的字节码
    final byte[] classBytes = clazz.toBytecode();

    // inject class bytes into instance
    Reflections.setFieldValue(
        templates,
        "_bytecodes",
        new byte[][] {
                classBytes,
                ClassFiles.classAsBytes(Foo.class)
        });

    // required to make TemplatesImpl happy
    Reflections.setFieldValue(templates, "_name", "Pwnr");
    Reflections.setFieldValue(templates, "_tfactory", new TransformerFactoryImpl());

    // 只要触发这个方法就能执行我们注入的bytecodes
    // templates.getOutputProperties();
    return templates;
}
```

通过精心构造的`TemplatesImpl`对象，通过触发`getOutputProperties`函数执行，后面会有分析。

## 0x03 漏洞分析

漏洞的利用主要涉及`AnnotationInvocationHandler`、`TemplatesImpl` 、``LinkedHashSet` `类，下面我们逐一分析当中的作用。

**大概的反序列化对象的图解**

```
  LinkedHashSet
       |  |
       |  `--> Proxy (Templates) 
       |         |
       |         `--> AnnotationInvocationHandler 
       |                      |
       |                      `--> HashMap
       |                            |  |
       |                            |  `----> String ("f5a5a608")
       |                            |
       `-----> TemplatesImpl <------`
                    |
                    `-------> byte[] (malicious class definition)
```

**反序列化的调用链**

```
LinkedHashSet.readObject()
  LinkedHashSet.add()
    ...
      TemplatesImpl.hashCode() (X)
  LinkedHashSet.add()
    ...
      Proxy(Templates).hashCode() (X)
        AnnotationInvocationHandler.invoke() (X)      
          AnnotationInvocationHandler.hashCodeImpl() (X)
            String.hashCode() (0)
            AnnotationInvocationHandler.memberValueHashCode() (X)
              TemplatesImpl.hashCode() (X)
      Proxy(Templates).equals()
        AnnotationInvocationHandler.invoke()
          AnnotationInvocationHandler.equalsImpl()
            Method.invoke()
              ...
                TemplatesImpl.getOutputProperties()
                  TemplatesImpl.newTransformer()
                    TemplatesImpl.getTransletInstance()
                      TemplatesImpl.defineTransletClasses()
                        ClassLoader.defineClass()
                        Class.newInstance()
                          ...
                            MaliciousClass.<clinit>()
                              ...
                                Runtime.exec()
```

### **TemplatesImpl类**

该类在payload中作用：

* 成员变量`_bytecodes`存储执行的恶意代码
* 提供加载恶意字节码并触发执行的函数，触发`getOutputProperties()`方法

该类用于 `xml document `的处理和转换，定义如下：

![Snipaste_2019-01-15_13-12-50](C:\Users\three_world\Desktop\code\threeworld.github.io\images\Snipaste_2019-01-15_13-12-50.png)

看出`TemplatesImpl` 类实现了 `Templates` 和 `Serializable` 两个接口

`Templates`接口的定义如下：

```java
public interface Templates {
    /**
     * Create a new transformation context for this Templates object.
     * @return A valid non-null instance of a Transformer.
     */
    Transformer newTransformer() throws TransformerConfigurationException;
    /*
     * @return A Properties object, never null.
     */
    Properties getOutputProperties();
}
```

里面有刚才想要触发的`getOutputProperties()`方法，那么来看看`TemplatesImpl` 类中实现的`getOutputProperties`方法

![Snipaste_2019-01-15_13-27-24]({{site.url}/images/Snipaste_2019-01-15_13-27-24.png)

调用`getOutputProperties` 方法后，会调用`newTransformer`方法，我们跟进`newTransformer`

![Snipaste_2019-01-15_13-31-33]({{site.url}/images/Snipaste_2019-01-15_13-31-33.png)

仔细观察，发现该函数也调用`getTransletInstance()` 方法，继续跟进

![Snipaste_2019-01-15_13-35-26]({{site.url}/images/Snipaste_2019-01-15_13-35-26.png)

有两个需要注意的地方，第一是`defineTransletClasses()`方法，第二是对传进来的对象实例化。`defineTransletClasses()` 执行后，会调用之前加载的 Class 的 `newInstance()` 方法来创建实例，触发 `static block` 和 `constructor `的执行。

我们看看`defineTransletClasses()`方法，该方法的核心代码：

![Snipaste_2019-01-15_13-39-04]({{site.url}/images/Snipaste_2019-01-15_13-39-04.png)

在方法中，调用了 `ClassLoader.defineClass()` 方法，参数为实例变量 `_bytecodes` 内的元素，该方法会将字节数组转换为 Class，并加载。

也就是说，通过设置 `_bytecodes` 的内容 ，调用 `defineTransletClasses()`方法即可加载指定的 Class。

大致的函数调用关系：

![getOutputProperties]({{site.url}/images/getOutputProperties.png)

大致思路：

* 使用 `javassist` 库创建一个包含恶意代码的 class，恶意代码可以在 static block中，或在无参构造函数里
* 将恶意 class 的的字节码添加到 TemplatesImpl 实例的 `_bytecodes` 变量中
* 调用实例的 `getOutputProperties()` 或 `newTransformer()` 方法触发恶意代码执行

可以看到调用 `getOutputProperties()` 或 `newTransformer()` 方法均可触发恶意代码的执行。

那么我们需要找到一个在反序列化过程中，自动执行该方法的类，于是我们找到了`AnnotationInvocationHandler`类

### AnnotationInvocationHandler类

在构造 payload 中，利用了 `AnnotationInvocationHandler` 提供的 `equals`方法的默认实现，来触发对 `Tempaltes` 接口中 `getOutputProperties()` 或 `newTransformer()` 的调用，具体来看一下`AnnotationInvocationHandler` 的定义

![Snipaste_2019-01-15_14-06-36]({{site.url}/images/Snipaste_2019-01-15_14-06-36.png)

可以看到实现了 `InvocationHandler` 和 `Serializable` 两个接口，根据动态代理部分的介绍，使用 `AnnotationInvocationHandler `创建的 `proxy object `的所有方法调用都会变成对 invoke 方法的调用，来看一下方法的实现![Snipaste_2019-01-15_14-08-18]({{site.url}/images/Snipaste_2019-01-15_14-08-18.png)

可以看到当调用方法名为`equals` 时，且参数个数和类型匹配，则调用内部 `equalsImpl` 方法

![Snipaste_2019-01-15_14-10-28]({{site.url}/images/Snipaste_2019-01-15_14-10-28.png)

跟入后可以看到，首先获取 `type` Class 所有声明的方法，然后在参数 Object o 上使用反射调用方法，因此前面所说 **TemplatesImpl** 实例是需要作为参数传入，此处调用的方法即是`getOutputProperties`方法。

调用关系：

![AnnotationInvocationHandler]({{site.url}/images/AnnotationInvocationHandler.png)



所以我们构造payload的大致思路：

1. 根据` TemplatesImpl` 部分的说明，创建一个包含恶意代码的 `TemplatesImpl `实例 `Templates`
2. 使用 `AnnotationInvocationHandler` 创建` proxy object `代理` Templates `接口 (会使用到反射)
3. 调用 proxy object 的 `equals` 方法，将 `Templates` 作为参数

### LinkedHashSet类

在利用 payload 中，`LinkedHashSet `是最外层的类，包含恶意代码的实例和`proxy object `会作为元素添加到 set 中，在反序列化过程中，会调用到前一部分所说的 `equals` 方法。

其实`HashSet`本质上就是一个`HashMap<key, new Object()>`，key是我们存进去的数据，而value就是静态的Object对象。

在反序列化过程中，会依次调用每个元素的 `readObject()` 方法，然后将其作为 `key` (value 为固定值Object对象) 依次放入 HashMap 中。

当LinkedHashSet被反序列的时候，会调用其父类HashSet的readObject方法。

![Snipaste_2019-01-15_14-33-30]({{site.url}/images/Snipaste_2019-01-15_14-33-30.png)

根据代码逻辑，意思是在反序列化过程中会依次将`templates`和`proxy`加入到map中，继续跟进put方法

![Snipaste_2019-01-15_14-36-12]({{site.url}/images/Snipaste_2019-01-15_14-36-12.png)

`put`方法首先会调用内部 `hash()` 函数计算 key 的 hash 值，然后遍历所有元素，**当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时**，则认为 key 是否已经存在，返回` oldValue`，否则调用 `addEntry()` 添加元素

注意到`equals`方法，**代码中将已有元素的 key 值作为参数 (k 变量)，调用了插入 key 的 equals方法来判断而这是否相等**，这里我们只要反序列化过程中让 `proxy object` 先添加，然后再添加包含恶意代码的实例 (序列化时添加要顺序相反)。然后就可以调用`equals`方法，进而触发`getOutputProperties`方法。

那么我们就有思路了

1. 创建`LinkedHashSet`类
2. 先将恶意代码的`Templates` 对象添加到 hashSet 中
3. 将使用` AnnotationInvocationHandler `创建的`proxy object` (代理 `Templaes `接口) 添加到` hashSet `中，在反序列化过程中，会调用 `proxy `的 `equals` 方法 (包含恶意代码的Templates 对象作为参数)，触发恶意代码执行

在反序列化过程中，需要保证 `HashSet` 内的 `entry` 保持有序，这也是为什么使用 `LinkedHashSet` 的原因

### 绕过hash

在上面代码中，看到一个很重要的判断，决定能否执行到`equals`函数

```java
 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {}
```

为了调用到最后的key.equals方法，根据逻辑短路原理，必须让`e.hash == hash`为true，并且`(k = e.key) == key`为false， `(k = e.key) == key`比较两个变量是否指向同一个对象，(一个为包含恶意代码的templates 实例，一个为proxy object)。

`e.hash`是`entry`存在的对象，`hash`是将要添加的对象的hash，当执行到`put(proxy)`的时候，map里实际上已经有第一个`templates`，这里的hash就是`proxy.hashCode`，`e.hash`就是`templates.hashCode`，也就是需要达成`proxy.hashCode()` == `templates.hashCode()`这个条件。

`AnnotationInvocationHandler` 提供了`hashCode`的实现：

![Snipaste_2019-01-15_14-57-05]({{site.url}/images/Snipaste_2019-01-15_14-57-05.png)

内部调用`hashCodeImpl()` 方法：

```java
private int hashCodeImpl() {
  int result = 0;
  // 遍历 memberValues
  Iterator itr = this.memberValues.entrySet().iterator();
  for( ;itr.hasNext(); ) {
      Entry entry = (Entry)itr.next();
      String key = ((String)entry.getKey());
      Object value = entry.getValue();
      // 127 * key 的 hashCode，再和 memberValueHashCode(value) 进行异或
      result += 127 * key.hashCode() ^ memberValueHashCode(value);
  }
  return result;
}
```

继续跟进后发现该方法会从`memberValues`中进行遍历，并且依次计算`key.hashCode()`，而这个`memberValues`是我们在初始化`AnnotationInvocationHandler`的时候传入的：

![Snipaste_2019-01-15_15-00-34]({{site.url}/images/Snipaste_2019-01-15_15-00-34.png)

我们再来看看`memberValueHashCode`方法

![Snipaste_2019-01-15_15-03-00]({{site.url}/images/Snipaste_2019-01-15_15-03-00.png)

所以`hashCodeImpl`方法可以看成

```java
result += 127 * key.hashCode() ^ value.hashCode()
```

此时的`value`是我们构造的恶意代码`templates`类，所以使`key.hashCode()==0`，`result`才能等于`valueCode()`，这个时候就需要上面说的`"f5a5a608".hashcode==0`，所以我设置`map`中的`key`为`f5a5a608`

整个hash计算就变成了`templates.hashCode()`，所以`proxy.hashCode() == templates.hashCode()`也就成立了。

## 0x04 简单调试分析

在`HashSet`的`readObject()`方法下了断点，

![Snipaste_2019-01-15_15-22-28]({{site.url}/images/Snipaste_2019-01-15_15-22-28.png)

根据这一部分的逻辑，可以看出来在反序列化的时候，会依次将`templates`和`proxy`加入到map中，跳过`templates`的添加，可以看到此时set中已经有`templates`对象

![Snipaste_2019-01-15_15-25-01]({{site.url}/images/Snipaste_2019-01-15_15-25-01.png)

接下来是添加`proxy`对象，跟进put方法：

![Snipaste_2019-01-15_15-29-55]({{site.url}/images/Snipaste_2019-01-15_15-29-55.png)

由于我们代理了`templates`接口，当调用到`templates.equals()`的时候，自然会调用到`handler`的`invoke`方法，这里也就是会调用`proxy.equals(templates)`方法。继续跟进

![Snipaste_2019-01-15_15-32-20]({{site.url}/images/Snipaste_2019-01-15_15-32-20.png)

这里调用`equalsImpl`方法，符合我们所想，再跟进

![Snipaste_2019-01-15_15-36-26]({{site.url}/images/Snipaste_2019-01-15_15-36-26.png)

可以看到已经调用了方法`newTransformer`方法，之后就按照刚才分析的调用链执行，执行完后弹出计算器

![Snipaste_2019-01-15_15-38-32]({{site.url}/images/Snipaste_2019-01-15_15-38-32.png)

调用链：

![Snipaste_2019-01-15_15-51-51]({{site.url}/images/Snipaste_2019-01-15_15-51-51.png)

整体的调用链也和作者的一样，大致分析到此。

## 0x05 修复建议

升级JDK，版本大于7u21。在 jdk > 7u21 的版本，修复了这个漏洞，看了下 7u79 的代码，`AnnotationInvocationHandler` 的构造方法，增加了对参数的校验，type 必须为 Annotation，所以会导致原有 payload 执行失败

## 0x06 总结

已经分析完这个漏洞了，还有一些细节需要慢慢消化，有些复杂。

payload地址：https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Jdk7u21.java